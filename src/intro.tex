\Intro

Software systems are required to be reliable. For example, biomedical implants must be able to operate autonomously within patients, adapting to short term and long term changes, with required lifetimes in the order of decades, and one"/minute downtime failure of banking software may lead to significant expenses. Safety and solidity of software may be achieved through testing and post"/design quality assurance, but there is always a possibility to leave some branches of an operations scenario untested, leading to potential disaster.

In contrast with post"/design testing, that doesn’t provide full
correctness guarantees, formal methods provide a systematic approach for developing
complex systems in a correct"/by"/construction manner. One reason of advancement of
formal methods in comparison to testing is a maximal possible elimination of human errors.
For instance, techniques known as model checking perform exhaustive search
through entire space of possible states of the system and evaluating its status in
every single case, completely excluding any possibility of non"/specified behaviour
(presuming the correctness of a specification).

One class of formal verification techniques involve the advanced type systems of
modern programming languages. Powerful yet lightweight formal verification
provided by these languages are based on famous Curry"/Howard correspondence ---
a direct relationship between computer programs and mathematical
proofs --- that was discovered by the American mathematician Haskell Curry and logician
William Alvin Howard in late 1960s. A perfectly written Philip Wadler’s paper
``Propositions as Types''~\cite{Wadler:2015:PT:2847579.2699407}
contains a great set of historical notes alongside with points of view on
Curry"/Howard correspondence from different fields of
mathematics and computer science. Curry"/Howard correspondence is of great value
for software developers because it provides a possibility to formulate desired
properties of programs in terms of types and automatically check
the correctness of those programs through type checking.

Advances in type theory and theory of programming languages led to the development
and spreading of effects systems --- a particular kind of type"/guided verification
providing a possibility to separate pure computations from ones flavoured with
a computational side effect, like, for instance, file system IO. These techniques
was first given an account by Moggi~\cite{Moggi:1991:NCM:116981.116984} who
used monads to provide a denotational semantics to lambda calculus with effects, and then Wadler~\cite{Wadler:1992:EFP:143165.143169} gave monads a practical instantiation in Haskell programming language.

Computational effects control techniques got plenty of attention both in academic and software engineering communities. As applications, such as, for example, parser combinators~\cite{monParsing} were explored, a lot more requirements and demands
were introduced: combine effects in a modular way and provide finer"/grained control
for effects. This led to development of both monadic~\cite{Liang:1995:MTM:199448.199528} and alternative approaches~\cite{Mcbride:2008:APE:1348940.1348941}
~\cite{DBLP:journals/jlp/BauerP15}.

This work aims to application of programming languages' features supporting explicit
and precise control of computational effects. It addresses the problem
of construction of parser combinators libraries and full"/scale web applications
using three approaches to effectful programming:

\begin{itemize}
  \item Monad transformers~\cite{Liang:1995:MTM:199448.199528} in Haskell.
  \item Algebraic effects and effects handlers~\cite{DBLP:journals/jlp/BauerP15}
  in a form of extensible.
  effects~\cite{Kiselyov:2013:EEA:2578854.2503791} in Haskell
  \item~\texttt{Frank}~\cite{DBLP:conf/popl/LindleyMM17} programming language featuring first-class support of algebraic
  effects and effects handlers.
\end{itemize}

Main results of this work were presented in international and local conferences.
The work on constructing parsers with extensible effects was presented in \nth{4}
international conference ``Tools and Methods of Program Analysis 2017''~\cite{tmpaExtEffects}
in Moscow. The material on construction of parsers in Frank was presented in the
conference ``Programming languages and compilers 2017'' in Rostov-on-Don~\cite{plcFrank}.

Tell about structure of this thesis.

\Goal

The goal of this work is to study the applications of approaches to structuring
of computational effects to real"/world software development. The gives an analysis
of monadic and algebraic effects and handlers frameworks by presenting a solution
to a standard model problem: building a parser combinators library. The work
include a comparison of these approaches in terms of expressiveness and, for some of them,
performance and makes observations about their applicability.

This thesis addresses the stated goal by breaking it into the following tasks:

\begin{itemize}
  \item Develop a monadic parser combinators library to illustrate the usage of
  monad transformers in Haskell.
  \item Develop a parser combinators library on top of extensible effects --- an embedding of
  algebraic effects into Haskell.
  \item Highlight the differences between monad transformers and extensible effects.
  \item Use Frank programming language
  featuring first"/class support of algebraic effects and effects handlers to develop
  a prototype of parser combinators library and report the experience.
  \item Demonstrate the usage of the typed functional programming language with an
  effect system at scale: develop a full"/featured effect"/structured web application
  with Haskell.
\end{itemize}

\Ackns

Firstly, I would like to thank my advisor Prof. Artem Pelenitsyn for his support, motivation,
knowledge and qualification. Prof. Pelenitsyn was the first person who exposed me to real
research activities. I thank him also for being a person who cares. I doubt I would have started
to do research on functional programming if I wouldn't have his support at one critical moment
in the past.

Besides my advisor, I would like to thank Prof. Vitaly Bragilevsky for being the best teacher
I've met. His courses on the theory of computation, functional programming and certified
software development have advanced my knowledge and skills crucially. Besides being an excellent
computer science teacher, Prof. Bragilevsky is also an inspiring, motivating and concerned,
person. Thanks to his support, I've been able to go on an academic exchange programme and get
the experience which made me rethink many aspects of my life.

I thank the other teachers and my fellow students for all the assistance I've received and for a
perfect study environment I've had though all these years.

Last but not the least, I would like to thank my family for always giving me a support if I was
in need.