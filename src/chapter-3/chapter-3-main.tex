\chapter{Building parser combinators as effectful programmes}
\label{cpt-parsers}

A parser is a necessary part of a broad range of software systems: from web browsers
to compilers. Parsers may be automatically generated or hand-written. Like any
software, parsers can carry implementation errors. One of the possible
methods of development of robust and correct-by-design software is using a programming
language with a rich type system. Modern programming languages offer facilities of
lightweight program verification using strict static typing discipline.

Parsing could be thought as a computation that operates over an input sequence of
characters, carrying some state (i.e. current position in input) and have a
possibility to fail. These features are computational effects. Chapter~\ref{cpt-effects}
introduced the most popular approaches to the construction of effectful computations and
this one show how these methods could be used to build parser combinators.

One of the approaches to parser construction that benefits from eloquent type system
is monadic parser combinators~\cite{monParsing}. Is has been widely accepted by the
community and was used to implement industrial-grade \texttt{Haskell} libraries, such
as \texttt{Parsec}~\cite{parsec} and \texttt{Attoparsec}~\cite{attoparsec}. This
approach represents parser as a monad and produces parsers powerful enough to admit
context-sensitive grammars. Section~\ref{cpt-parsers:monadic} gives an account to this kind of parsers.

A parser could be represented not only by monadic computation but also by an
applicative functor~\cite{Mcbride:2008:APE:1348940.1348941}. An applicative interface
is less restrictive than monadic one, but even though, it is possible to capture
context-free grammars. These parsers are described in
section~\ref{cpt-parsers:applicative}.

It is also feasible to represent an interface of a parser as an algebraic effect and
the process of analysis as a handler for this effect. Unlike monads and applicative functors,
algebraic effects do not still have wide support in popular programming languages.
Section~\ref{cpt-parsers:alg-eff} shows how parsing could be expressed using this
approach and provides examples in an experimental programming language~\texttt{Frank}
that has built-in support for algebraic effects and handlers.

  \section{Monadic parsers}
  \label{cpt-parsers:monadic}

    \subsection{Monads in Haskell}
      Monads were firstly injected into programming languages context as a tool to
      assign a denotational semantics to computational effects~\cite{Moggi:1991:NCM:116981.116984}. Later, the have been adopted as a programming
      paradigm and introduced into functional programming languages~\cite{Wadler:1992:EFP:143165.143169}. Monads are sometimes refereed as a ``programmable semicolon'' --- a powerful way to construct sequences of computation with possible side-effect. Afterwards, even more notions from category theory were given first-class support in modern programming languages, providing programmers with highly abstract, powerfully expressive and mathematically structured ways to build software.

      In \texttt{Haskell} programming language, monads are types that have an instance of \texttt{Monad} type class and satisfy three laws. They are used
      to distinguish pure computations from ones having some kind of side effect:
      mutable state, exceptions, non-determinism, etc.

      \begin{figure}[h]
      \begin{lstlisting}
class Monad m where
  (>>=)  :: m a -> (a -> m b)   -> m b
  (>>)   :: m a ->  m b         -> m b
  return ::   a                 -> m a
  fail   :: String -> m a
      \end{lstlisting}
      \caption{\texttt{Monad} type class}
      \label{listing:monadClass}
      \end{figure}

      \begin{figure}[h]
      \begin{lstlisting}
return a >>= k                  =  k a
m        >>= return             =  m
m        >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
      \end{lstlisting}
      \caption{Monad laws}
      \label{listing:monadLaws}
      \end{figure}

      The \lstinline{>>=} operation, also known as \emph{monadic bind}, represents
      a, mentioned earlier, ``programmable semicolon''. It takes a value in a monadic context as it first argument, an action that transforms that value as a second argument and returns a transformed value in the same monadic context.

      Monads have broad usage in functional programming. They are first-class citizens
      in purely-functional languages like~\texttt{Haskell} and a wide range of~\texttt{Haskell}-libraries have monadic interface. Mainstream programming languages also
      employ specific monads in a form of build-in language constructions,
      i.e.~\texttt{LINQ} in~\texttt{C\#} or optionals in~\texttt{Swift}.

      As it was previously said, monads are used to characterise types of computations with a particular side effect. But what if a computation may
      potentially produce two or more effects? Then, means to combine several
      computational effects are needed. Monadic approach provide notion of
      ~\emph{monad transformer}~\cite{Liang:1995:MTM:199448.199528} --- a type that
      may add properties of a given monad to any other. Monad transformers are widely
      used in~\texttt{Haskell} to build computations carrying multiple side effects.


    \subsection{Parser as a Monad}

      Consider a simple type to represent a parser.

      \begin{figure}[h]
      \begin{lstlisting}
type Parser a = String -> Maybe (a,String)
      \end{lstlisting}
      \caption{Basic parser type}
      \label{listing:maybeParser}
      \end{figure}

      In this representation, parser is a
      function, taking input stream and returning a list of possible valid
      variants of analysis in conjunction with corresponding input stream
      remains. Empty list of result stands for completely unsuccessful attempt of
      parsing, whereas multiple results mean ambiguity.

      Types similar to \texttt{Parser a} may be treated as effectful computation.
      To represent computations with effects a concept of
      \texttt{Monad} is used in~\texttt{Haskell} programming language. This particular
      type could be made an instance of \texttt{Monad} type class.
      Comprehensive information about properties of parsers like one presented
      above may be found in paper~\cite{monParsing}.

      To extend capabilities and improve convenience of syntactic analysers, set of
      effects of parser could be expanded: it is handy to run parsers in a configurable
      environment or introduce logging. In this section two approaches to combination
      of computational effects will be considered: monad transformers and extensible
      effects.

    \subsection{Factorising parser into monad transformers stack}

  \section{Applicative parsing}
  \label{cpt-parsers:applicative}

  \section{Parsers as algebraic effects}
  \label{cpt-parsers:alg-eff}

  Algebraic effects and effects handlers provide an alternative to monads and monad
  transformers way to express effectful computations. Building parser combinators in
  term of algebraic effects and the process of parsing as their handlers is a solid
  model problem to find out strengths and weaknesses of this approach.

  This section describes leads to prototype implementations of parser
  combinators libraries in experimental programming language
  Frank~\cite{DBLP:conf/popl/LindleyMM17} which has first-class support for
  algebraic effects and effects handlers. Parsers may be represented either by
  combination of multiple effects, for instance, mutable state and possible failure,
  or may be expressed as a monolith effect signature. In conclusion, a
  note on expressive power of Franks implementation of algebraic effects and
  handlers is made.

  \subsection{As a combination of effects}

    Section~\ref{cpt-effects:alg-effects} gives an account on algebraic effects and
    effects handlers and, in particular, on programming with these concepts in Frank
    programming language. This section employs Frank to build a prototype of parser
    combinators library.

    \subsubsection{Defining parser combinators}

    As is has been already said, simple parser could be expressed as a computation
    with two effects: state of input stream and a possibility of failure. Thus,
    handling parsing means handling a combination of those two effects, that is done
    by composing handlers for failure and state (see
    listing~\ref{listing:parserHandlerCombo}).

    \begin{figure}[h]
    \begin{lstlisting}
parse : {[Error, State (List Char)] X} -> (List Char) -> Maybe X
parse p str = catch (state str p!)
    \end{lstlisting}
    \caption{Handling combination of state and failure}
    \label{listing:parserHandlerCombo}
    \end{figure}

    First parser that serves as a most basic building block in construction of
    more advanced ones is the~\emph{unconditional consumer}.
    It must take the first item
    of the input stream and yield it as a result, updating the state of the input
    stream with it's remains. In case of exhausted input, parser must fail. That
    is exactly the behaviour described by~\lstinline{item} function of listing
    ~\ref{listing:parserItemCombo}.

    \begin{figure}[h]
    \begin{lstlisting}
item : [Error, State (List Char)] Char
item! = on get! { nil -> fail
                | (x :: xs) -> put xs; x}
    \end{lstlisting}
    \caption{Parser consuming single item}
    \label{listing:parserItemCombo}
    \end{figure}

    Of course, unconditional consumption of the input stream without any actions
    doesn't make much sense. Actually, we would prefer consuming some items to others. Thus,~\emph{conditional consumer} that checks if an item satisfies a
    given predicate prior to consuming and fails otherwise, must be
    implemented (~\ref{listing:parserSatCombo}).

    \begin{figure}[h]
    \begin{lstlisting}
sat : {Char -> [Error, State (List Char)] Bool} ->
      [Error, State (List Char)] Char
sat p = on item! {c -> if (p c) {c} {fail}}
    \end{lstlisting}
    \caption{Conditional consumer}
    \label{listing:parserSatCombo}
    \end{figure}

    Having these basic building blocks, we are already able to construct
    practical parsers. A useful application of~\texttt{sat} is
    the~\texttt{char} parser that accepts a given character from the input
    stream (listing~\ref{parserCharCombo}).

    \begin{figure}[h]
    \begin{lstlisting}
char : Char -> [Error, State (List Char)] Char
char c = sat {x -> eqChar x c}
    \end{lstlisting}
    \caption{Parser for a given character}
    \label{listing:parserCharCombo}
    \end{figure}

    Besides accepting specific characters,~\texttt{sat} parser could be used
    to implement other basic parsers. For instance, if predicate
    ~\texttt{isLetter} determining weather of not given character is Latin letter is defined, we could supply it to~\texttt{sat} and acquire a parser for letters (listing~\ref{listing:parserLetterCombo}). The same could be done for decimal
    (or other) digits.

    \begin{figure}[h]`
    \begin{lstlisting}
letter : [Error, State (List Char)]Char
letter! = sat isLetter

digit : [Error, State (List Char)]Char
digit! = sat isDigit
    \end{lstlisting}
    \caption{Parsers letters and digits}
    \label{listing:parserLetterCombo}
    \end{figure}

    Now, being able to parse singular characters, we can make ourselves a task
    to accept sequences. That could be useful, for example, to parse terminals of
    some grammar. Here the main power of Frank's effect support comes in handy.
    As far as a string is essentially a list of characters, we can use the
    standard~\texttt{map} function in presence of~\texttt{Error}
    and~\texttt{State (List Char)}~\emph{abilities}.

    \begin{figure}[h]
    \begin{lstlisting}
string : (List Char) ->
         [Error, State (List Char)] (List Char)
string str = map char str
    \end{lstlisting}
    \caption{Parser for a given string}
    \label{listing:parserStrCombo}
    \end{figure}

    But individual chars and known-in-advance strings are not that interesting. Therefore, turn comes to actually building actual combinators: alternative
    and repetition.

    Consider the case we have to parsers $p_1$ and $p_2$, and we would like to
    construct a parser that accepts all inputs that are recognisable by both
    $p_1$ and $p_2$. In our setting we could implement this by deterministic
    choice: we apply $p_1$ and yield the result if it succeeds, otherwise we
    apply $p_2$ and initialise an error if it has failed, returning its
    result in case of success.

    \begin{figure}[h]
    \begin{lstlisting}
choose : {[Error, State (List Char)] X} ->
         {[Error, State (List Char)] X} ->
          [Error, State (List Char)] X
choose p1 p2 =
  on (parse p1 get!) { (right _)  -> p1!
                     | (left  _)  ->  on (parse p2 get!)
                       { (right _)   -> p2!
                       | (left err)  -> throw err
                       }
                     }
    \end{lstlisting}
    \caption{Alternative combinator}
    \label{listing:parserChooseCombo}
    \end{figure}

    For the simplest instance for~\texttt{choose} usage, reconsider
    ~\texttt{letter} and~\texttt{digit} parsers. We could combine those with the
    alternative combinator to accept alphanumeric characters
    (listing~\ref{listing:parserAlphanumCombo}).

    \begin{figure}[h]
    \begin{lstlisting}
alphanum : [Error, State (List Char)]Char
alphanum! = choose digit letter
    \end{lstlisting}
    \caption{Parser for alphanumerics}
    \label{listing:parserAlphanumCombo}
    \end{figure}

    The motivation for repetition combinators is the need to apply an already defined
    parser multiple times with no certainty about the amount of required applications.
    Repetition combinators are useful for problems like parsing a sequence
    of statements of a programming language. In parser combinators approach,
    repetition combinators are usually defined as two mutually recursive functions:
    ~\texttt{many} accepts the result of zero or more applications of its
    argument-parser $p$ and~\texttt{some} succeeds if $p$ is applicable at least
    once.

    \begin{figure}[h]
    \begin{lstlisting}
many : {[Error, State (List Char)]X} ->
        [Error, State (List Char)](List X)
many p = choose {some p} {nil}

some : {[Error, State (List Char)] X} ->
        [Error, State (List Char)](List X)
some p = p! :: many p
    \end{lstlisting}
    \caption{Repetition combinators}
    \label{listing:parserManyCombo}
    \end{figure}

    As an example of repetition combinator usage, consider parser for words ---
    a sequence of letters (listing~\ref{listing:parserWordCombo}).

    \begin{figure}[h]
    \begin{lstlisting}
word : [Error, State (List Char)] (List Char)
word! = some letter
    \end{lstlisting}
    \caption{Parser for words}
    \label{listing:parserWordCombo}
    \end{figure}

    \subsubsection{Using parsers}

      \begin{figure}[h]
      \begin{lstlisting}
data Expr = Plus Expr Expr
          | Val Int
      \end{lstlisting}
      \caption{Addition expressions AST}
      \label{listing:parserExprCombo}
      \end{figure}

      \begin{figure}[h]
      \begin{lstlisting}
expr : [Exception ParseError, State (List Char)] Expr
expr! = on number! { x -> on (char ' ') { _ -> on number! {y -> Plus x y}}}
      \end{lstlisting}
      \caption{Pseudo-monadic style of defining parsers}
      \label{listing:parserExprMonCombo}
      \end{figure}

      \begin{figure}[h]
      \begin{lstlisting}
expr : [Exception ParseError, State (List Char)] Expr
expr! = Plus number! (char ' '; number!)
      \end{lstlisting}
      \caption{Direct applicative style of defining parsers}
      \label{listing:parserExprAppCombo}
      \end{figure}

      \begin{figure}[h]
      \begin{lstlisting}
main : {Either ParseError Expr}
main! = parse expr "23 32"
      \end{lstlisting}
      \caption{Using expressing parser}
      \label{listing:parserExprMainCombo}
      \end{figure}

    \subsubsection{Discussion}

    Frank provides convenient and expressive features for programming with
    algebraic effects and handlers. Frank's native support for computations with
    multiple effects doesn't require programmes to deal with much of boilerplate.
    When the collection of effects of computation is determined, there is nothing
    more holding the programmer from working: no need to wrap one's head around
    complex types like monad transformers stacks and static effects ordering.
    In addition, direct applicative style of defining effectful computations often
    leaves in unnecessary to give names to interim results, thus making code
    easier to follow.

    Because Frank is in its infancy, it lacks some useful language features that
    are habitual from more mature functional languages. For example, there is no
    way to declare any short-cut for part of type signature, hence the
    effect peg must be included in type signature of every parser combinator, making
    source code a bit more verbose than in could be.

    Representing parser as a computation combining several side effects is a
    triumph of modularity. Nevertheless, it somehow abuses one of the most important
    points about algebraic effects and effect handlers: the independence of
    syntax and semantics. Of course, parsing is perfectly representable by the
    combination of several algebraic effects, but it might also be interesting
    and useful to represent it as a separate effect signature to be able to assign
    different interpretations to the same parser's syntax. Potential usefulness
    of this is discussed in the next subsection.


  \subsection{As a standalone effect}


