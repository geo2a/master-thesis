\chapter{Computational effects}
~\label{cpt-effects}

  % Some fairly general words on why computational effects are useful: pure and impure programs, resource-sensitivity... Separate effects, combining several effects into one, modularity issues.

  Recent advances in theory of programming languages led to development and spreading
  of functional programming languages with advanced type systems. This provide
  software engineers a possibility to encode system specification in type-level, enforcing statically checked guaranties of correctness. A large cluster of errors is
  introduced into programs by uncontrolled side effects such as file system IO,
  network communication and mutable state. When many mainstream programming languages such as C++, Java and C\# follow static type discipline, they do not track
  side-effects, thus making it harder to reason about program correctness. In contrast,
  pure languages like Haskell and Idris forbid programs to execute effectful code
  without special type annotations.

  \begin{figure}[h]
  \begin {lstlisting}
  int plus(int x, int y) {
    print("I'm mutating the World without you noticing!");
    return x + y;
  }
  \end{lstlisting}
  \caption{Uncontrollable side-effect in impure language}
  \label{listing:effectfulPlus}
  \end{figure}

  \begin{figure}[h]
  \begin{lstlisting}
plus :: Int -> Int -> Int
plut x y = x + y
  \end{lstlisting}
  \caption{Pure Haskell function}
  \label{listing:purePlusHaskell}
  \end{figure}

  \begin{figure}[h]
  \begin{lstlisting}
plusIO :: Int -> Int -> IO Int
plutIO x y = do
  print "I'm mutating the World, but you know it"
  return (x + y)
  \end{lstlisting}
  \caption{Pure Haskell function}
  \label{listing:purePlusHaskell}
  \end{figure}

  After initial incorporation of side-effect control techniques in Haskell in
  form of Monads~\cite{Wadler:1992:EFP:143165.143169}, effects systems got a lot
  of development. Monadic approach has been enriched with the concept of monad
  transformers~\cite{Liang:1995:MTM:199448.199528} to provide a modular way of
  expressing computations with multiple side-effects. Even though monad
  transformers has been widely accepted as a modular approach to side effects control,
  they have some major drawbacks, that are addressed, for instance, by Kiselyov at al.~\cite{Kiselyov:2013:EEA:2578854.2503791}, and alternative approach --- Algebraic effects and effects handlers --- was proposed~\cite{DBLP:journals/jlp/BauerP15}
  ~\cite{Kiselyov:2013:EEA:2578854.2503791}. Some studies were carried out to
  compare expressive power of these approaches~\cite{DBLP:journals/corr/ForsterKLP16}.
  This chapter introduces main approaches to construction of effectful computation
  by example, with illustrations in Haskell and Frank programming languages.

  \section{Monads and monad transformers}

  Paper~\cite{Liang:1995:MTM:199448.199528} describes a concept of a monad
  transformer --- a building block for types describing computations with
  multiple side effects. Every transformer is a building block, possessing one
  effect: mutable state, configuration, exceptions, etc.
  Transformers are put on top of a base monad to form a \emph{monad stack} --- a
  type characterising a computation with multiple side effects. Consider
  an example of a function in a monad combining effects of mutable state and
  configuration (listing~\ref{listing:mtlAdder}).

  \begin{figure}[h]
  \begin{lstlisting}
adder :: StateT String (Reader Int) Int
adder = do
  str <- get
  num <- ask
  return $ num + read str

adder' :: (MonadState String m, MonadReader Int m) => m Int
adder' = ...
  \end{lstlisting}
  \caption{Effectful adder based on monad transformers}
  \label{listing:mtlAdder}
  \end{figure}

  Here \texttt{adder} and \texttt{adder'} describe the same computation, but the first
  function is bounded to specific monad stack, while second just restricts effects
  that the stack ought to provide.

  One characteristic of monad stack is that ordering of monads is statically encoded
  in the type, so there is no runtime control of effect interaction.
  The Second problem of monad transformers is a need to write a lot of boilerplate
  type class instances, that is, to add a new effect, every possible combination
  of newly added effect with existing ones must be covered with instances to provide
  automatic lifting, thus $\mathcal{O}(n^2)$ instances must be written,
  where $n$ is a number of monad transformers provided by the developing library.

  \begin{figure}[h]
  \begin{lstlisting}
class Monad m => MonadNew a m where
  action1 :: m a
  action2 :: m ()

instance MonadNew m => MonadNew (ExceptT e m) where
  action1 = lift action1
  action2 = lift action2

instance MonadNew m => MonadNew (IdentityT m) where
  action1 = lift action1
  action2 = lift action2

  ...
  \end{lstlisting}
  \caption{Monad classes for lifting}
  \label{listing:mtlLift}
  \end{figure}

  And, finally, monad transformers do not provide a way to express computations that produce several homogeneous effects, e.g. two \texttt{State} effects, without losing automated lifting.

  Monad transformers are well established abstraction for building modular effectful
  computations. It has been widely accepted by Haskell community and a lot of
  useful libraries have been implemented on top of it. Nevertheless, it has some
  flaws regarding its convenience of use. Lately, algebraic effects and effects
  handlers --- an alternative approach to structuring of effectful computations
  has emerged. It has received wide account in recent publications~\cite{}
  and has several implementations in programming languages~\cite{}. The next
  sections gives a brief overview of two implementations: extensible effects library
  for Haskell and a Frank programming language.

  \section{Algebraic effects and effects handlers}
  ~\label{cpt-effects:alg-effects}

  This section contains a brief introduction to algebraic effects and effects
  handlers together with an overview of two implementations of this approach.
  One is extensible
  effects by Kiselyov at al.~\cite{Kiselyov:2013:EEA:2578854.2503791} --- a library
  that uses free and freer~\cite{Kiselyov:2015:FMM:2887747.2804319} monads to embed
  algebraic effects and effects handlers into Haskell.
  The second one is Frank programming
  language~\cite{DBLP:conf/popl/LindleyMM17} that incorporates algebraic effects
  directly into language core. Chapter~\ref{cpt-parsers} of this thesis describes
  a case-study of using these approaches to implement parser combinators libraries.


    \subsection{Extensible Effects}

    \subsection{Frank programming language}